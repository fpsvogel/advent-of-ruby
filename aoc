#!/usr/bin/env ruby

require "fileutils"
require "httparty"
require "dotenv/load"
require "thor"
require "benchmark"
require "reverse_markdown"
require "yaml"
require "date"
require "debug"

cli_files = File.join(File.dirname(__FILE__), "cli", "*.rb")
solution_files = File.join(File.dirname(__FILE__), "solutions", "**", "*.rb")
Dir[cli_files].each { |file| require file }
Dir[solution_files].each { |file| require file }

CONFIG = YAML.load(File.read("config.yml"))

# TODO in the two validate methods, raise errors to be rescued, instead of returning nil
def validate_year_and_day(year, day, default_from:)
  if year && day
    # The first two digits of the year may be omitted.
    year = "20#{year}" if year.length == 2
  elsif (year && !day) || (day && !year)
    puts "Please specify both year and day, or neither."
    return nil
  elsif !year && !day
    case default_from
    when :untracked
      untracked_solutions = `git status -s | grep "^?? solutions/"`

      if untracked_solutions.empty?
        puts "Could not find an untracked solution file. Please run the command again with the year and day."
        return nil
      end

      match = untracked_solutions.match(/(?<year>\d{4})\/(?<day>\d\d).rb$/)
      year, day = match[:year], match[:day]
    when :last_committed
      last_committed_solution = `git log -n 1 --name-only --pretty=format: solutions`.lines.last

      unless last_committed_solution
        puts "Could not find a committed solution file. Please `aoc bootstrap` again with the year and day."
        return nil
      end

      match = last_committed_solution.match(/(?<year>\d{4})\/(?<day>\d\d).rb$/)
      year, day = match[:year], match[:day].next
    else
      raise "Invalid `default_from` param."
    end
  end

  year = Integer(year, exception: false) || (puts "Year must be a number." && (return nil))
  day = Integer(day, exception: false) || (puts "Day must be a number." && (return nil))

  unless year.between?(2015, Date.today.year)
    puts "Year must be between 2015 and this year."
    return nil
  end
  unless day.between?(1, 25) && Date.new(year, 12, day) <= Date.today
    puts "Day must be between 1 and 25, and <= today."
    return nil
  end

  [year.to_s, day.to_s]
end

def validate_part_and_get_solved(year, day, part)
  if part && !%w[1 2].include?(part)
    puts "The \"part\" argument must be 1 or 2."
    return nil
  end

  part_solved = nil
  instructions_file_path = InstructionsFile.path(year, day)
  if !part && File.exist?(instructions_file_path)
    instructions = File.read(instructions_file_path)
    if instructions.include?("Both parts of this puzzle are complete!")
      part_solved = "1"
    elsif instructions.include?("## --- Part Two ---")
      part_solved = "2"
    end
  end

  [part, part_solved]
end

# The CLI application
class Aoc < Thor
  desc "bootstrap YEAR DAY", "prepares a sample project for a given day and year:
downloads the input and instructions, creates a sample source and spec file"
  method_option :bootstrap, aliases: "-b"
  def bootstrap(year = nil, day = nil)
    year, day = validate_year_and_day(year, day, default_from: :last_committed)

    input_path = InputFile.download(year, day)
    instructions_path = InstructionsFile.download(year, day)
    source_path = SourceFile.create(year, day)
    spec_path = SpecFile.create(year, day)
    others_1_path, others_2_path = OtherSolutionsFiles.download(year, day)

    puts "https://adventofcode.com/#{year}/day/#{day}"

    # Open the downloaded and created files.
    `#{CONFIG["editor_command"]} #{others_2_path}`
    `#{CONFIG["editor_command"]} #{others_1_path}`
    `#{CONFIG["editor_command"]} #{input_path}`
    `#{CONFIG["editor_command"]} #{source_path}`
    `#{CONFIG["editor_command"]} #{spec_path}`
    `#{CONFIG["editor_command"]} #{instructions_path}`
  end

  # TODO add a [VARIANT] arg, so that additional versions of the same solution
  # can co-exist as additional methods, e.g.:
  #
  #   #part_1_first     # for my initial attempt
  #   #part_1_concise   # for a code-golf type solution
  #   #part_1_alt       # for an alternative approach
  desc "run YEAR DAY [PART]", "executes a given day, year, and optionally part"
  method_option :run_day, aliases: "-r"
  def run_day(year = nil, day = nil, part = nil)
    year, day = validate_year_and_day(year, day, default_from: :untracked) || return

    part, part_solved = validate_part_and_get_solved(year, day, part) || return

    solution = Runner.load_solution(year, day)
    input_path = InputFile.download(year, day, notify_exists: false)
    url = "https://adventofcode.com/#{year}/day/#{day}"
    answer_1, answer_2 = nil, nil

    if part == "1" || part_solved.nil? || part_solved == "2"
      answer_1 = Runner.run_part("Part One") { solution.part_1(File.new(input_path)) }
      puts
    end
    if part == "2" || part_solved
      answer_2 = Runner.run_part("Part Two") { solution.part_2(File.new(input_path)) }
      puts
    end

    return unless answer_1 || answer_2

    return if part_solved == "2"

    puts url
    puts "Submit solution? (y/N)"
    submit = STDIN.gets.chomp.downcase

    if submit == "y"
      inferred_part = part_solved.nil? ? "1" : "2"
      aoc_api = AocApi.new(ENV["AOC_COOKIE"])
      response = aoc_api.submit(year, day, part || inferred_part, answer_2 || answer_1)
      message = response.match(/(?<=<article>).+(?=<\/article>)/).to_s.strip
      markdown_message = ReverseMarkdown.convert(message)
      # TODO debug when a blank line is output in some success cases
      debugger if message.blank? || markdown_message.strip.blank?

      puts "Submitting #{url}"
      puts
      puts markdown_message

      if markdown_message.start_with?("That's the right answer!")
        instructions_path = InstructionsFile.download(year, day, overwrite: true)
        if (part || inferred_part) == "2"
          puts "Downloaded instructions for Part Two."
        end
        `#{CONFIG["editor_command"]} #{instructions_path}`
      end
    end
  end
end

Dotenv.load("#{__dir__}/.env")
Dotenv.require_keys("AOC_COOKIE")
Aoc.start
