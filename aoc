#!/usr/bin/env ruby

require "fileutils"
require "httparty"
require "dotenv/load"
require "thor"
require "pastel"
require "benchmark"
require "reverse_markdown"
require "yaml"
require "date"
require "rspec/core"
require "debug"

class InputError < StandardError; end

cli_files = File.join(File.dirname(__FILE__), "cli", "*.rb")
solution_files = File.join(File.dirname(__FILE__), "solutions", "**", "*.rb")
Dir[cli_files].each { |file| require file }
Dir[solution_files].each { |file| require file }

CONFIG = YAML.load(File.read("config.yml"))
PASTEL = Pastel.new

# The CLI application
class Aoc < Thor
  desc "bootstrap YEAR [DAY]", "for a given year and day (defaults to Day 1), " \
    "creates files: input, instructions, other solutions, source, and specs"
  method_option :bootstrap, aliases: "-b"
  def bootstrap(year = nil, day = nil)
    year, day = validate_year_and_day(year, day)

    input_path = InputFile.download(year, day)
    instructions_path = InstructionsFile.download(year, day)
    source_path = SourceFile.create(year, day)
    spec_path = SpecFile.create(year, day)
    others_1_path, others_2_path = OtherSolutionsFiles.download(year, day)

    puts "🤘 Bootstrapped #{year}##{day}"

    # Open the new files.
    `#{CONFIG["editor_command"]} #{others_1_path}`
    `#{CONFIG["editor_command"]} #{others_2_path}`
    `#{CONFIG["editor_command"]} #{input_path}`
    `#{CONFIG["editor_command"]} #{source_path}`
    `#{CONFIG["editor_command"]} #{spec_path}`
    `#{CONFIG["editor_command"]} #{instructions_path}`
  rescue InputError => e
    puts Pastel.new.red(e.message)
  end

  # TODO add a [VARIANT] arg, so that additional versions of the same solution
  # can co-exist as additional methods, e.g.:
  #
  #   #part_1_first     # for my initial attempt
  #   #part_1_concise   # for a code-golf type solution
  #   #part_1_alt       # for an alternative approach
  desc "run YEAR DAY [PART]", "executes a given day, year, and optionally part"
  method_option :run_day, aliases: "-r"
  def run_day(year = nil, day = nil, part = nil)
    year, day = validate_year_and_day(year, day, default_untracked_or_done: true) || return

    if part && !%w[1 2].include?(part)
      raise InputError, "The \"part\" argument must be 1 or 2."
    end

    solution = Runner.load_solution(year, day)
    input_path = InputFile.download(year, day, notify_exists: false)
    url = "https://adventofcode.com/#{year}/day/#{day}"
    answer_1, answer_2 = nil, nil

    instructions_path = InstructionsFile.download(year, day, notify_exists: false, overwrite: false)
    instructions = File.read(instructions_path)
    correct_answer_1, correct_answer_2 = instructions.scan(/Your puzzle answer was `([^`]+)`./).flatten

    specs_passed = run_specs(year, day)
    return unless specs_passed

    if part == "1" || correct_answer_1.nil? || (correct_answer_2 && part != "2")
      answer_1 = Runner.run_part("#{year}##{day}.1", correct_answer_1) do
        solution.part_1(File.new(input_path))
      end
    end
    if part == "2" || (correct_answer_1 && !correct_answer_2) || (correct_answer_2 && part != "1")
      answer_2 = Runner.run_part("#{year}##{day}.2", correct_answer_2) do
        solution.part_2(File.new(input_path))
      end
    end

    return unless answer_1 || answer_2

    if part != "1" && correct_answer_2
      puts "🙌 You've already submitted the answers to both parts."
      return
    elsif part == "1" && correct_answer_1
      puts "🙌 You've already submitted the answer to this part."
      return
    end

    puts "Submit solution? (Y/n)"
    submit = STDIN.gets.chomp.downcase

    if submit == "y" || submit == ""
      inferred_part = correct_answer_1.nil? ? "1" : "2"
      aoc_api = AocApi.new(ENV["AOC_COOKIE"])

      response = aoc_api.submit(year, day, part || inferred_part, answer_2 || answer_1)
      message = response.match(/(?<=<article>).+(?=<\/article>)/m).to_s.strip
      markdown_message = ReverseMarkdown.convert(message)
      short_message = markdown_message
        .sub(/\n\n.+/m, "")
        .sub(/ \[\[.+/, "")

      if short_message.start_with?("That's the right answer!")
        puts "⭐ #{short_message}"

        instructions_path = InstructionsFile.download(year, day, overwrite: true)

        if (part || inferred_part) == "1"
          puts "Downloaded instructions for Part Two."
          `#{CONFIG["editor_command"]} #{instructions_path}`
        end
      else
        puts "❌ #{short_message}"
      end
    end
  rescue InputError => e
    puts PASTEL.red(e.message)
  end

  desc "status", "shows progress, total and by year, based on the number of " \
    "your solutions committed in Git"
  method_option :status, aliases: "-s"
  def status
    past_year_count = 25 * (Date.today.year - 1 - 2015)
    this_year_count = (Date.today.month == 12 ? Date.today.day : 0).clamp(..25)
    total_count = past_year_count + this_year_count

    my_counts_by_year = `git ls-files solutions/`
      .split("\n")
      .select { |path| File.basename(path).match?(/\d\d\.rb/) }
      .group_by { |path| File.basename(File.dirname(path)) }
      .transform_values(&:count)
    my_total_count = my_counts_by_year.values.sum

    total_percent = (my_total_count.to_f / total_count * 100).round(1)
    total_percent == total_percent.to_i ? total_percent.to_i : total_percent

    puts "You have completed:\n\n"
    puts PASTEL.bold "#{PASTEL.blue("All:")}\t#{total_percent}% \t#{my_total_count}/#{total_count} puzzles\n"

    my_counts_by_year.each do |year, my_count|
      if year.to_i == Date.today.year
        year_count = this_year_count
      else
        year_count = 25
      end

      year_percent = (my_count.to_f / year_count * 100).round

      puts "#{PASTEL.blue(year + ":")}\t#{year_percent}%\t#{my_count}/#{year_count}"
    end
  end

  private

  def run_specs(year, day)
    padded_day = day.rjust(2, "0")
    out = StringIO.new
    spec_filename =	[File.join("spec", year, "#{padded_day}_spec.rb")]
    RSpec::Core::Runner.run(spec_filename, $stderr, out)

    if out.string.match?(/Failures:/)
      RSpec.reset
      RSpec::Core::Runner.run(spec_filename)

      false
    else
      true
    end
  end

  def validate_year_and_day(year, day, default_untracked_or_done: false)
    # The first two digits of the year may be omitted.
    year = "20#{year}" if year && year.length == 2

    if day && !year
      raise InputError, "If you specify the day, specify the year also."
    elsif !day
      if default_untracked_or_done
        untracked_solutions = `git status -su | grep "^?? #{File.join("solutions", year || "")}"`

        unless untracked_solutions.empty?
          match = untracked_solutions.match(/(?<year>\d{4})\/(?<day>\d\d).rb$/)
          year, day = match[:year], match[:day]
        end
      end

      if !default_untracked_or_done || untracked_solutions.empty?
        if year && !Dir.exist?(File.join("solutions", year))
          FileUtils.mkdir_p(File.join("solutions", year))
          day = "1"
        else
          last_committed_solution = `git log -n 1 --name-only --pretty=format: #{File.join("solutions", year || "")}`.lines.last

          unless last_committed_solution
            raise InputError, "Could not find a committed solution file. " \
              "Run `aoc bootstrap` again with the year and day."
          end

          match = last_committed_solution.match(/(?<year>\d{4})\/(?<day>\d\d).rb$/)

          year, day = match[:year], match[:day]
          day = day.next unless default_untracked_or_done
        end
      end
    end

    year = Integer(year, exception: false) || (raise InputError, "Year must be a number.")
    day = Integer(day, exception: false) || (raise InputError, "Day must be a number.")

    unless year.between?(2015, Date.today.year)
      raise InputError, "Year must be between 2015 and this year."
    end
    unless day.between?(1, 25) && Date.new(year, 12, day) <= Date.today
      raise InputError, "Day must be between 1 and 25, and <= today."
    end

    [year.to_s, day.to_s]
  end
end

Dotenv.load("#{__dir__}/.env")
Dotenv.require_keys("AOC_COOKIE")
Aoc.start
